# 트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다.
# 모든 노드는 서로 다른 x값을 가진다.
# 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다.
# 자식 노드의 y 값은 항상 부모 노드보다 작다.
# 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다.
# 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.

# 곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때,
# 노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.

# heap 모듈을 이용해서 먼저 이쁜 트리를 만드는 것을 목표로 하자

# 1. 최초에는 heap을 이용해서 정렬하려고 했으나, 문제가 최소/최대 그 어느것도 만족하지 않아서 패스
import heapq

nodeinfo = [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]]

# 2. 주어진 예시에 3번째 요소로 실제 노드의 값 추가
tre = []
for idx in range(len(nodeinfo)):
    nodeinfo[idx] += [idx+1]
ㅁㄴㅇ
# x[1] == y를 내림차순, x[0] == x를 내림차순으로 정렬,
# 이제 test 리스트는 높이 순으로 정렬된 트리 구조가 됨
test = sorted(nodeinfo,key= lambda x : (-x[1],x[0]))
print(test)

# 그리고 이제 이것을 우리가 아는 입력꼴로 만들어야하는데.. -> 입력값에 자식 노드의 정보가 들어있는 형태
# 그게 잘 구현이 안됩니다 ㅠㅠ

# for node in nodeinfo:
#     heapq.heappush(tre,(-node[1],[node])) # 내 생각, y 크기 내림차순, x 크기 오름차순으로 정렬
# print(tre)
