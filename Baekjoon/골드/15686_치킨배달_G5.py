# #15686 ì¹˜í‚¨ë°°ë‹¬
# í¬ê¸°ê°€ NÃ—Nì¸ ë„ì‹œê°€ ìˆë‹¤. ë„ì‹œëŠ” 1Ã—1í¬ê¸°ì˜ ì¹¸ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆë‹¤. ë„ì‹œì˜ ê° ì¹¸ì€ ë¹ˆ ì¹¸, ì¹˜í‚¨ì§‘, ì§‘ ì¤‘ í•˜ë‚˜ì´ë‹¤. 
# ë„ì‹œì˜ ì¹¸ì€ (r, c)ì™€ ê°™ì€ í˜•íƒœë¡œ ë‚˜íƒ€ë‚´ê³ , rí–‰ cì—´ ë˜ëŠ” ìœ„ì—ì„œë¶€í„° rë²ˆì§¸ ì¹¸, ì™¼ìª½ì—ì„œë¶€í„° cë²ˆì§¸ ì¹¸ì„ ì˜ë¯¸í•œë‹¤. rê³¼ cëŠ” 1ë¶€í„° ì‹œì‘í•œë‹¤.
# ì´ ë„ì‹œì— ì‚¬ëŠ” ì‚¬ëŒë“¤ì€ ì¹˜í‚¨ì„ ë§¤ìš° ì¢‹ì•„í•œë‹¤. ë”°ë¼ì„œ, ì‚¬ëŒë“¤ì€ "ì¹˜í‚¨ ê±°ë¦¬"ë¼ëŠ” ë§ì„ ì£¼ë¡œ ì‚¬ìš©í•œë‹¤. 
# ì¹˜í‚¨ ê±°ë¦¬ëŠ” ì§‘ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ì¹˜í‚¨ì§‘ ì‚¬ì´ì˜ ê±°ë¦¬ì´ë‹¤. ì¦‰, ì¹˜í‚¨ ê±°ë¦¬ëŠ” ì§‘ì„ ê¸°ì¤€ìœ¼ë¡œ ì •í•´ì§€ë©°, 
# ê°ê°ì˜ ì§‘ì€ ì¹˜í‚¨ ê±°ë¦¬ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ë„ì‹œì˜ ì¹˜í‚¨ ê±°ë¦¬ëŠ” ëª¨ë“  ì§‘ì˜ ì¹˜í‚¨ ê±°ë¦¬ì˜ í•©ì´ë‹¤.
# ë„ì‹œì— ìˆëŠ” ì¹˜í‚¨ì§‘ ì¤‘ì—ì„œ ìµœëŒ€ Mê°œë¥¼ ê³ ë¥´ê³ , ë‚˜ë¨¸ì§€ ì¹˜í‚¨ì§‘ì€ ëª¨ë‘ íì—…ì‹œì¼œì•¼ í•œë‹¤. 
# ì–´ë–»ê²Œ ê³ ë¥´ë©´, ë„ì‹œì˜ ì¹˜í‚¨ ê±°ë¦¬ê°€ ê°€ì¥ ì‘ê²Œ ë ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.



# ì²«ì§¸ ì¤„ì— N(2 â‰¤ N â‰¤ 50)ê³¼ M(1 â‰¤ M â‰¤ 13)ì´ ì£¼ì–´ì§„ë‹¤.
# ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ë„ì‹œì˜ ì •ë³´ê°€ ì£¼ì–´ì§„ë‹¤.
# ë„ì‹œì˜ ì •ë³´ëŠ” 0, 1, 2ë¡œ ì´ë£¨ì–´ì ¸ ìˆê³ , 
# 0ì€ ë¹ˆ ì¹¸, 1ì€ ì§‘, 2ëŠ” ì¹˜í‚¨ì§‘ì„ ì˜ë¯¸í•œë‹¤. ì§‘ì˜ ê°œìˆ˜ëŠ” 2Nê°œë¥¼ ë„˜ì§€ ì•Šìœ¼ë©°, 
# ì ì–´ë„ 1ê°œëŠ” ì¡´ì¬í•œë‹¤. ì¹˜í‚¨ì§‘ì˜ ê°œìˆ˜ëŠ” Më³´ë‹¤ í¬ê±°ë‚˜ ê°™ê³ , 13ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤.

import sys
sys.stdin = open('15686_input.txt','r')
from pprint import pprint
from itertools import combinations
from collections import deque

# ê¸°ë³¸ ì•„ì´ë””ì–´.. í‘œë³¸ ìˆ˜ê°€ ì ìœ¼ë‹ˆê¹Œ ë¸Œë£¨íŠ¸ í¬ìŠ¤ ì´ìš©í•´ë„ ëœë‹¤.
# ì¼ë‹¨ ì¹˜í‚¨ì§‘ì´ Mê°œ ë‚¨ì„ë•Œê¹Œì§€ ë‹¤ ì§€ì›Œë³´ëŠ” ê²ƒì´ë‹¤.
# ì •í™•íˆ ë§í•˜ìë©´, ì¹˜í‚¨ì§‘ ëª©ë¡ì—ì„œ ì¹˜í‚¨ì§‘ì´ M ê°œ ë‚¨ì€ ì¡°í•©ì„ ë§Œë“¤ì–´ì„œ, ê·¸ ê° ì¡°í•©ì— ëŒ€í•´ ì¹˜í‚¨ê±°ë¦¬ë¥¼ êµ¬í•˜ë©´ ëœë‹¤. -> itertools ì´ìš©
# ì¹˜í‚¨ê±°ë¦¬ëŠ” BFSë¡œ ì´ìš©í•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œ?
# ê·¸ ì „ì— ì¸í’‹ì— í•œì¤„/ í•œì—´ ì”© ì¶”ê°€í•´ì¤˜ì„œ ì¸ë±ìŠ¤ë¥¼ 0ë¶€í„° í™œìš©í•  ìˆ˜ ìˆê²Œ í•˜ì.
N,M = map(int,input().split())
KFC = [] # ì¹˜í‚¨ ì§‘ì˜ ìœ„ì¹˜
home = [] # ë„ì‹œì— ìˆëŠ” ì§‘ ìœ„ì¹˜

for i in range(1,N+1):
    city_block = list(map(int,input().split()))
    for j in range(N):
        if city_block[j] == 1:
            home.append([i,j+1])
        elif city_block[j] == 2:
            KFC.append([i,j+1])


# combinationsëŠ” í•œë²ˆ ì“°ê³  ë°©ì¶œëœë‹¤ê³  í•˜ë„¤...
survivor = combinations(KFC,M)

new_city = [[0]*(N+1) for _ in range(N+1)]
for h in home :
    home_x = h[0]
    home_y = h[1]
    new_city[home_x][home_y] = 1

# ì´ì œ ì—¬ê¸°ì„œë¶€í„° ì‚´ì•„ë‚¨ì€ ë‹­ì§‘ í•˜ë‚˜ì”© ì§‘ì–´ë„£ê³ , BFS ëŒë¦¬ë©´ ëœë‹¤.
# ì—¬ê¸°ì„œ BFS ëŒë¦°ë‹¤.

def BFS(copyed_home:list,new_city:list,min_dis:int):

    # ì¼ë‹¨ ê° ì§‘ì—ì„œ ì¹˜í‚¨ì§‘ ê°€ëŠ”ê±° êµ¬í˜„ deque ê°€ì ¸ì™€ë¼

    # ë¸íƒ€ ë¬´ë¸Œ / ìƒí•˜ì¢Œìš°
    dx = [1,-1,0,0]
    dy = [0,0,-1,1]
    
    chicken_dis = 0
    while copyed_home:
        # ë°©ë¬¸ì²˜ë¦¬ êµ¬í˜„...ì´ê±° ì™œ ë§¨ë‚  ê¹Œë¨¹ì„ê¹Œ
        visited = [[False]*(N+1) for _ in range(N+1) ]
        if min_dis >= chicken_dis: # ì´ê±´ ìµœê³  ê¸°ë¡ë³´ë‹¤ ë„˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ ì•„ì§ ì•ˆë„˜ì—ˆìœ¼ë©´ (TRUE) -> ê³„ì† ì§„í–‰ -> ì•„ë‹ˆë©´ ì¢…ë£Œ (False)
            # í ì´ˆê¸°í™”
            que = deque()
            que.append(copyed_home.pop())
            [init_x,init_y] = que[0]
            flag = False
            while que:
                x,y = que.popleft()
                for i in range(4):
                    new_x = x+dx[i]
                    new_y = y+dy[i]
                    # ì¸í’‹ì´ í¬ì•ˆí•˜ê²Œ ë“¤ì–´ì™€ì„œ ë²”ìœ„ì²´í¬ ë°©ì‹ë„ ì¢€ ë‹¤ë¥´ë‹¤.
                    if 1<=new_x<=N and 1<=new_y<=N and not visited[new_x][new_y]:
                        if new_city[new_x][new_y] == 2:
                            chicken_dis += abs(new_x-init_x) + abs(new_y-init_y)
                            flag = True
                            break
                        else:
                            que.append([new_x,new_y])
                            visited[new_x][new_y] = True
                if flag:
                    break
        else:
            return 0xfffff
    
    # ìˆœíšŒ ëë‚˜ê³ , ì—¬ê¸°ì„œ ìµœì†Œ ê±°ë¦¬ ê²½ì‹ í•¨
    return chicken_dis

min_dis = 0xffffff
result = 0
for s in survivor:
    clean_it =[]
    copyed_home = home[:]
    for market in s:
        KFC_x = market[0]
        KFC_y = market[1]
        new_city[KFC_x][KFC_y] = 2
        clean_it.append([KFC_x,KFC_y])
    result= BFS(copyed_home,new_city,min_dis)
    for elem in clean_it:
        new_city[elem[0]][elem[1]] = 0
    if result < min_dis:
        min_dis = result


print(min_dis)
# ì‹œê°„ ì´ˆê³¼... ğŸ¤¬
