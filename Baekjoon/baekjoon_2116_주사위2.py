# 2116.주사위 쌓기

"""
천수는 여러 종류의 주사위를 가지고 쌓기 놀이를 하고 있다.
주사위의 모양은 모두 크기가 같은 정육면체이며 각 면에는 1부터 6까지의 숫자가 하나씩 적혀있다.
그러나 보통 주사위처럼 마주 보는 면에 적혀진 숫자의 합이 반드시 7이 되는 것은 아니다.


주사위 쌓기 놀이는 아래에서부터 1번 주사위, 2번 주사위, 3번 주사위, … 의 순서로 쌓는 것이다. 쌓
을 때 다음과 같은 규칙을 지켜야 한다:

서로 붙어 있는 두 개의 주사위에서 아래에 있는 주사위의 윗면에 적혀있는 숫자는
위에 있는 주사위의 아랫면에 적혀있는 숫자와 같아야 한다.


다시 말해서, 1번 주사위 윗면의 숫자는 2번 주사위 아랫면의 숫자와 같고,
2번 주사위 윗면의 숫자는 3번 주사위 아랫면의 숫자와 같아야 한다.


단, 1번 주사위는 마음대로 놓을 수 있다.


이렇게 쌓아 놓으면 긴 사각 기둥이 된다.
이 사각 기둥에는 4개의 긴 옆면이 있다.
이 4개의 옆면 중에서 어느 한 면의 숫자의 합이 최대가 되도록 주사위를 쌓고자 한다.
이렇게 하기 위하여 각 주사위를 위 아래를 고정한 채 옆으로 90도, 180도, 또는 270도 돌릴 수 있다.
한 옆면의 숫자의 합의 최댓값을 구하는 프로그램을 작성하시오.

첫줄에는 주사위의 개수가 입력된다.
그 다음 줄부터는 한 줄에 하나씩 주사위의 종류가 1번 주사위부터 주사위 번호 순서대로 입력된다.
주사위의 종류는 각 면에 적혀진 숫자가 그림1에 있는 주사위의 전개도에서 A, B, C, D, E, F 의 순서로 입력된다.
입력되는 숫자 사이에는 빈 칸이 하나씩 있다.
주사위의 개수는 10,000개 이하이며 종류가 같은 주사위도 있을 수 있다.

"""

# 일단 입력값들을 잘 받아주자

# TC = int(input())
# TC = 1
# 주사위 값에 따라 제거될 값의 인덱스
# A: 5(F) B: 3(D) C:4(E) D:1(B) E:2(C) F:0(A)
#remove_idx = {0:5,1:3,2:4,3:1,4:2,5:0}

"""

이 문제는 생각해보니, 전부 다, 바닥 주사위의 값 / 그리고 바닥 주사위의 맞은편에 있는 값
을 제외한 나머지 중 최고값을 반복해서 구하는게 핵심이다.

구해진 최고값은 더해서 매 경우, 즉 첫번째 주사위의 놓음 방식에 따라 생기는 6가지 경우에서
최고값을 구하면 된다. 

"""#          0 1 2 3 4 5
#             A B C D E F
remove_idx = [5,3,4,1,2,0]
# 옆면 합 받을 리스트
max_num = 0

#N = int(input())
N = 5
#dice_tower = [list(map(int,input().split())) for _ in range(N)]
dice_tower = [[2,3,1,6,5,4],[3,1,2,4,6,5],[5,6,4,1,3,2],[1,3,6,2,4,5],[4,1,6,5,2,3]]

# 처음 주사위를 놓는 6가지의 방식
for i in range(6):
    result = []
    # 원본 리스트인 dice_tower를 훼손하지 않고 쓸 임시 주사위
    # 어짜피 우리는 여기서 윗면, 아랫면만 제거한 max값만이 관심있어서
    tem =[1,2,3,4,5,6]
    # dt의 첫번째 행에서 i번째 요소를 제거한다.
    # 1번 주사위의 6가지 면에 대해서 다 조사할 것이므로, 순서는 중요치 않다.
    tem.remove(dice_tower[0][i])
    # tem = [1,3,4,5,6]
    # 그리고, next라는 변수는 첫번째 주사위에서, i의 위치.에 반대편에 있는 값이 할당된다.
    next = dice_tower[0][remove_idx[i]] 
    # next = dice_tower[0][3] ==> 6
    # 그리고 그 값 역시 제거 해준다
    tem.remove(next)
    # tem = [1,3,4,5]
    # 남은 값중에서 최대 값 찾아서 append
    result.append(max(tem))

    # 첫번째 주사위의 위 아래가 결정되면 사실 나머지는 자동으로 결정되는 것이다.
    for j in range(1,N):
        tem = [1,2,3,4,5,6]
        # 여기서의 next는 바닥 값이 된다.
        tem.remove(next)
        # 새 값이 할당되는 next는 이번 j번째 주사위의 천장값이 되는데, 이게 좀 복잡하다
        # 이번 바닥값의 맞은편 값을 구해야한다.
        # 이번 바닥값은 dice_tower[j][remove_idx의 키 == 이번 주사위 j 에서의 아까 next의 위치]
        # 이번 주사위 j에서 아까 next의 위치의 반대값                                                
        next = dice_tower[j][remove_idx[dice_tower[j].index(next)]]
        tem.remove(next)
        result.append(max(tem))
    result = sum(result)
    if max_num < result:
        max_num = result
    #print(result)
#print()
print(max_num)
#print(dice_tower)
