# 10158번 개미
import sys

sys.stdin = open('10158_input.txt', 'r')
w, h = map(int, input().split())  # 좌 우 격자
p, q = map(int, input().split())  # 시작점
t = int(input())

drc = [1, -1] # drc[0] --> 오른쪽/위로 이동한다. drc[1] --> 왼쪽/ 아래로 이동한다. // 벽에 닿을때마다 두 값이 전환되게 설계할 것이다.

a = 0
b = 0
time = 0

# 이하 2줄이 이 문제의 핵심이라고 볼 수 있다. 시간 t를 어떻게 줄여야하는지를 알아야한다.
"""
개미가 같은 장소를 왔다 갔다 하는 것은 맞지만, 왕복 움직임을 하기 때문에 ( 끝 지점에 도달하면 다시 처음 지점으로 오는 것이 아니라, 역행함)
어찌 되었던 가로/ 세로를 왕복할 수 있을 만큼의 루프는 지켜봐줘야한다.
그렇기 때문에 시간 t를 w,h이 아니라, w와 h의 2배를 넘지 않는 값으로 바꿔준다.

x 시간과 y 시간을 구분 한 이유는, x축과 y축의 길이 차이가 있기 때문이다.
두 축의 길이 차이가 있다면, 원래 자리로 돌아오기 위한 시간도 달라지게 되는데, 루프를 도는 동안 이를 조건으로 삽입하여, 자신의 이동을 끝마치면 더 이상 이동하지 않게 하기 위함이다.
"""

# t를 쪼개준다. 이로서, t_x와 t_y는 제자리로 돌아온 뒤의 추가 이동횟수가 되었다.
# x는 w*2 만큼의 이동을 하면 자기 자리로, y는 h*2만큼의 이동을 하면 자기 자리로 오게 되는 패턴을 보고 도출한 결과이다.
t_x = t % (w * 2)
t_y = t % (h * 2)

t_final = max(t_x, t_y)

# 전체 while문은 x축과 y축 루프 중 더 큰 값만큼 돈다
while time < t_final:
    # 만약에 time이 t_x (추가 이동횟수) 보다 적으면, p를 이동 시켜준다
    # time이 t_x를 넘어섰다면, x축의 이동은 끝난 것이기에, 이 구문을 통째로 스킵하게 되는 것이다.
    if time < t_x:
        p += drc[a]
        # 만약 p가 이동했는데, 행렬을 벗어났다면, drc와 a(x축 방향전환 포인터)를 조절하여 다시 범위 내로 들어오게 해준다.
        if 0 > p or w < p:
            a += 1
            a = a % 2
            p += drc[a]
            p += drc[a]
    # 위의 조건문과 동일하다. time이 t_y(y축 방향으로의 이동횟수)보다 적으면 q를 이동시켜준다
    # time이 t_y를 넘어섰다면, y축의 이동은 끝난 것이기에, 이 구문을 통째로 스킵해준다.
    if time < t_y:
        q += drc[b]
        if 0 > q or h < q:
            b += 1
            b = b % 2
            q += drc[b]
            q += drc[b]

    time += 1
print(p, q)

